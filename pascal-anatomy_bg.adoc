= Анатомия на програма на Паскал

Паскал е императивен и процедурен език за програмиране, който Никлаус Вирт проектира през 1968-69 г. и публикува през 1970 г. 
като малък и ефективен език, предназначен да насърчава добрите практики като структурно програмиране и структурирани данни. 
Наречен е в чест на френския математик, философ и физик Блез Паскал. 
източник: https://en.wikipedia.org/wiki/Pascal_(programming_language)[wikipedia])

За да компилирате и стартирате програма на Паскал, можете да използвате https://www.freepascal.org/[Free Pascal Compiler].

[source,pascal]
----
// Анатомия на програма на Паскал
//това е коментар
{
    това е 
    коментар на няколко 
      реда
}

//име на програмата
program learn_pascal; //<-- не забравяйте точка и запетая (;)

const
    {
        тук трябва да декларирате константите си
    }
type
    {
        тук трябва да декларирате вашите нови 
        типове данни
    }
var
    {
        тук трябва да декларирате променливи
    }

//главна програма
begin
    {
        зона да напишете инструкциите
    }
end. // Край на главната програма, изисква символ "." накрая
----

[source,pascal]
----
//Когато декларирате променливи
//може да направите така
var a: integer;
var b: integer;
//или така
var 
    a: integer;
    b: integer;
//или така
var a, b: integer;
----

[source,pascal]
----
program Learn_More;
  // Нека научим за типовете данни и техните операции

const
  PI = 3.141592654;
  GNU = 'GNU''s Not Unix';
    // константите по конвенция се именуват с ГЛАВНИ букви
    // стойностите им са фиксирани и не могат да се променят по време на изпълнение
    // съдържа всякакъв стандартен тип данни (integer, real, boolean, char, string)

type
  ch_array = array [0..255] of char;
    // масивите са нови "типове", указващи дължината и типа на елементите
    // горното дефинира нов тип данни, който съдържа 255 знака
    // (това е функционално еквивалентно на променлива от тип string[256])
  md_array = array of array of integer;
    // вложените масиви са еквивалентни на многомерни масиви
    // може да дефинира масиви без дължина, които са с динамичен размер
    // горното е двумерен масив от цели числа

  //Declaring variables
var
  i, c, d: integer;
    // три променливи, които съдържат цели числа
    // целите числа могат да бъдат :
    //  - 16-битови и ограничени до диапазона [-32,768..32,767]  или
    //  - 32-битови и ограничени до диапазона [-2,147,483,648..2,147,483,647]
  r: real;
    // променлива, която съдържа реални типове данни
    // реалните стойности могат да варират между [5.0E-324 .. 1.7E308]
  bool: boolean;
    // променлива, която съдържа булева (True/False) стойност
  ch: char;
    // променлива, която съдържа символна стойност
    // char променливите се съхраняват като 8-битови типове данни, така че няма UTF
  str: string;
    // нестандартна променлива, която съдържа низова стойност
    // низовете са разширение, включено в повечето компилатори на Pascal
    // те се съхраняват или като масив от char с дължина по подразбиране 255 (shortstring) 
    // или са масив с динамичен размер (ansistring) в зависимост от режима на компилиране 
  s: string[50];
    // низ с максимална дължина от 50 знака.
    // можете да посочите дължината на низа, за да минимизирате използването на паметта
  my_str: ch_array;
    // можете да декларирате променливи от декларирани нови типове
  my_2d: md_array;
    // масивите с динамичен размер трябва да бъдат оразмерени, преди да се използват.

  // допълнителни целочислени типове
  b: byte;       // диапазон [0..255]
  shi: shortint; // диапазон [-128..127]
  smi: smallint; // диапазон [-32,768..32,767] (стандартен 16-bit Integer)
  w: word;       // диапазон [0..65,535]
  li: longint;   // диапазон [-2,147,483,648..2,147,483,647] (стандартен 32-bit Integer)
  lw: longword;  // диапазон [0..4,294,967,295]
  c: cardinal;   // longword
  i64: int64;    // диапазон [-9223372036854775808..9223372036854775807]
  qw: qword;     // диапазон [0..18,446,744,073,709,551,615]

  // допълнителни реални типове 
  rr: real;     // диапазон зависи от платформата (т.е., 8-bit, 16-bit, ...)
  rs: single;   // диапазон [1.5E-45..3.4E38]
  rd: double;   // диапазон [5.0E-324 .. 1.7E308]
  re: extended; // диапазон [1.9E-4932..1.1E4932]
  rc: comp;     // диапазон [-2E64+1 .. 2E63-1]

begin
  i := 1; // как да присвоите стойност на променлива
  r := 3.14;
  ch := 'a';
  str := 'apple';
  bool := True;
    // pascal е език, който не различава малки и големи букви
    // аритметични операции
  i := 1 + 1;   // i = 2 заменя стойността от предишното присвояване
  i := i + 1;   // i = 2 + 1 = 3;
  i := 4 div 2; // i = 2 целочислено делене, резултата ще е подравнен
  i := 3 div 2; // i = 1
  i := 1 div 2; // i = 0

  bool := True or False; // bool = true
  bool := False and True; // bool = false
  bool := True xor True; // bool = false

  r := 3 / 2; // делене на реални числа
  r := i;     // може да се присвоява цяло число на реално но не и обратното

  c := str[1]; // присвояване на първия символ от str на c
  str := 'hello' + 'world'; // комбиниране на низове

  my_str[0] := 'a'; // присвояването в масив изисква индекс

  setlength(my_2d, 10, 10); // задаване на размер на динамичен масив: 10×10 
  for c := 0 to 9 do // индексите на масив започват от 0 и свършват на дължината-1
    for d := 0 to 9 do // брояча на цикъл for трябва да е декларирана променлива
      my_2d[c, d] := c * d; // адресиране на многомерен масив с един набор от скоби

end.
----

[source,pascal]
----
program Functional_Programming;

var
  i, dummy: integer;

  function factorial_recursion(const a: integer): integer;
  { рекурсивно изчисляване на факториал на целочислен параметър a }

    // Деклариране на локални променливи във функцията
    // например:
    // var
    //    local_a : integer;

  begin
    if a >= 1 then
      // стойности от функции се връщат чрез присвояване на стойност на името на функцията
      factorial_recursion := a * factorial_recursion(a - 1)
    else
      factorial_recursion := 1;
  end; // завършете функция, като използвате точка и запетая след оператора End.

  procedure get_integer(var i: integer; dummy: integer);
  { вземете въведеното от потребителя и го запишете в целочисления параметър i.
    В параметрите, предшествани с 'var', се подават променливи, което означава, че тяхната стойност може да се промени заедно с параметъра. Параметри по стойност (без 'var') като 'dummy' са
    статични и промените, направени в обхвата на функцията/процедурата, няма да засегнат променливата, предадена като параметър }

  begin
    Write('Въведете цяло число: ');
    readln(i);
    dummy := 4; // dummy няма да се промени извън процедурата
  end;

begin // блок на основната програма
  dummy := 3;
  get_integer(i, dummy);
  writeln(i, '! = ', factorial_recursion(i));
  // изпиши i!
  writeln('dummy = ', dummy); // винаги изписва '3' защото dummy не се променя.
end.
----

Originally contributed by Ganesha Danu, and contributors, 2023
Edited by Y.Ivanov, 2023

License: https://creativecommons.org/licenses/by-sa/3.0/deed.en_US[Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)]